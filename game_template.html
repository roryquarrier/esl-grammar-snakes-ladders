<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakes and Ladders: Grammar Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ffe135;
            /* Nano Banana Yellow */
            --accent-color: #ff6b6b;
            --dark-glass: rgba(0, 0, 0, 0.7);
            --light-glass: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --board-border: #2d3436;
        }

        body {
            font-family: 'Fredoka', 'Segoe UI', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a2f1a;
            /* Dynamic Background Injection */
            background-image: url('/* BACKGROUND_IMAGE_B64 */');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: white;
            flex-direction: column;
        }

        /* Backdrop overlay for readability */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: -1;
        }

        #game-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 100%;
            backdrop-filter: blur(5px);
        }

        #board-container {
            flex: 2;
            background: var(--dark-glass);
            padding: 15px;
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        #board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 2px;
            width: 100%;
            aspect-ratio: 1;
            border: 5px solid rgba(255, 255, 255, 0.2);
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
        }

        .cell {
            background-color: rgba(255, 255, 255, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            font-weight: bold;
            font-size: 1.2rem;
            color: #2d3436;
        }

        .cell:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.7);
        }

        .cell:nth-child(odd) {
            background-color: rgba(255, 255, 255, 0.9);
        }

        /* Special Squares */
        .ladder-start {
            background-color: #e8f8f5 !important;
            border: 3px solid #00b894;
        }

        .snake-start {
            background-color: #ffeaa7 !important;
            border: 3px solid #ff7675;
        }

        .golden {
            background-color: #fdcb6e !important;
            border: 3px solid #ffe135;
            box-shadow: 0 0 10px #ffe135;
        }

        .marker {
            position: absolute;
            font-size: 0.8rem;
            bottom: 2px;
            right: 2px;
            opacity: 0.7;
        }

        /* Cute Blob Player Pieces */
        .player {
            width: 70%;
            height: 70%;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: absolute;
            z-index: 50;
            display: flex;
            justify-content: center;
            align-items: center;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.4));
            animation: bobbing 2s ease-in-out infinite;
        }

        .player.moving {
            animation: squash 0.3s ease-in-out;
        }

        .blob-svg {
            width: 100%;
            height: 100%;
        }

        .blob-body {
            fill: var(--player-color, #fff);
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
        }

        .blob-eyes {
            fill: #2d3436;
            animation: blink 4s infinite;
        }

        @keyframes bobbing {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-5px);
            }
        }

        @keyframes blink {

            0%,
            90%,
            100% {
                transform: scaleY(1);
            }

            95% {
                transform: scaleY(0.1);
            }
        }

        @keyframes squash {
            0% {
                transform: scale(1, 1);
            }

            50% {
                transform: scale(1.2, 0.8);
            }

            100% {
                transform: scale(1, 1);
            }
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            70% {
                transform: scale(1.2);
                opacity: 1;
            }

            100% {
                transform: scale(1);
            }
        }

        .pop-in {
            animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        /* Sidebar */
        #ui-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: var(--dark-glass);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            position: relative;
        }

        h2 {
            margin-top: 0;
            color: var(--primary-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #dice-btn {
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            font-weight: 600;
            padding: 15px 40px;
            background: linear-gradient(135deg, #ffe135 0%, #f39c12 100%);
            color: #2d3436;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(255, 225, 53, 0.4);
            margin-top: 10px;
        }

        #dice-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 5px rgba(255, 225, 53, 0.4);
        }

        #dice-result {
            font-size: 4rem;
            margin: 10px 0;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            perspective: 200px;
        }

        .dice-rolling {
            animation: diceRoll3D 0.1s ease-in-out infinite;
        }

        @keyframes diceRoll3D {
            0% {
                transform: rotateX(0deg) rotateY(0deg) scale(1.1);
            }

            25% {
                transform: rotateX(90deg) rotateY(45deg) scale(1.2);
            }

            50% {
                transform: rotateX(180deg) rotateY(90deg) scale(1.1);
            }

            75% {
                transform: rotateX(270deg) rotateY(135deg) scale(1.2);
            }

            100% {
                transform: rotateX(360deg) rotateY(180deg) scale(1.1);
            }
        }

        .dice-landed {
            animation: diceLand 0.3s ease-out forwards;
        }

        @keyframes diceLand {
            0% {
                transform: scale(1.3) rotateZ(10deg);
            }

            50% {
                transform: scale(0.9) rotateZ(-5deg);
            }

            100% {
                transform: scale(1) rotateZ(0deg);
            }
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal {
            background: linear-gradient(145deg, rgba(45, 52, 54, 0.95) 0%, rgba(30, 35, 36, 0.98) 100%);
            padding: 40px;
            border-radius: 24px;
            max-width: 650px;
            width: 90%;
            text-align: left;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.6),
                0 0 40px rgba(255, 225, 53, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 225, 53, 0.4);
            color: white;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }

        .modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
        }

        .question-text {
            font-size: 1.6rem;
            margin-bottom: 25px;
            line-height: 1.5;
            color: #ffffff;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, transparent 100%);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .options-grid {
            display: grid;
            gap: 12px;
        }

        .option-btn {
            padding: 18px 22px;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2rem;
            text-align: left;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.03) 100%);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s ease;
            position: relative;
            overflow: hidden;
        }

        .option-btn::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--primary-color);
            transform: scaleY(0);
            transition: transform 0.2s ease;
        }

        .option-btn:hover {
            background: linear-gradient(135deg, rgba(255, 225, 53, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            border-color: rgba(255, 225, 53, 0.4);
            transform: translateX(8px);
            box-shadow: 0 4px 15px rgba(255, 225, 53, 0.15);
        }

        .option-btn:hover::before {
            transform: scaleY(1);
        }

        .feedback {
            margin-top: 25px;
            padding: 24px;
            border-radius: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none;
            backdrop-filter: blur(12px);
            animation: slideUp 0.3s ease-out;
            text-align: left;
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .feedback.correct {
            border-color: rgba(46, 204, 113, 0.4);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2) 0%, rgba(0, 0, 0, 0.7) 100%);
            box-shadow: 0 0 30px rgba(46, 204, 113, 0.1);
        }

        .feedback.wrong {
            border-color: rgba(231, 76, 60, 0.4);
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.2) 0%, rgba(0, 0, 0, 0.7) 100%);
            box-shadow: 0 0 30px rgba(231, 76, 60, 0.1);
        }

        .feedback .feedback-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 15px;
            display: block;
        }

        .feedback.correct .feedback-title {
            color: #58d68d;
        }

        .feedback.wrong .feedback-title {
            color: #ff8a80;
        }

        .feedback .rule-box {
            background: rgba(255, 255, 255, 0.07);
            color: #efefef;
            padding: 20px;
            border-radius: 12px;
            margin: 15px 0;
            font-style: normal;
            border: 1px solid rgba(255, 255, 255, 0.1);
            line-height: 1.6;
            font-size: 1.1rem;
            border-left: 4px solid #ccc;
        }

        .feedback.wrong .rule-box {
            border-left-color: #e74c3c;
        }

        .feedback.correct .rule-box {
            border-left-color: #2ecc71;
        }

        .feedback .rule-box em {
            color: var(--primary-color);
            font-style: normal;
            font-weight: 600;
            display: block;
            margin-bottom: 10px;
        }

        .tag {
            background: linear-gradient(135deg, var(--primary-color) 0%, #f39c12 100%) !important;
            color: #2d3436 !important;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #setup-screen,
        #victory-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a2f1a;
            background-image: url('/* BACKGROUND_IMAGE_B64 */');
            background-size: cover;
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            align-items: center;
            text-align: center;
        }

        .setup-card {
            background: rgba(0, 0, 0, 0.85);
            /* High contrast background */
            padding: 40px;
            border-radius: 30px;
            border: 2px solid var(--primary-color);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        #setup-screen h1 {
            font-size: 4rem;
            color: var(--primary-color);
            text-shadow: 4px 4px 0px #000;
            margin-bottom: 10px;
        }

        #mascot-display {
            width: 150px;
            height: 150px;
            background-image: url('/* MASCOT_IMAGE_B64 */');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            margin: 20px auto;
            animation: bounce 2s infinite ease-in-out;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        .hidden {
            display: none !important;
        }

        /* Color Selection */
        .color-options {
            display: flex;
            gap: 20px;
            margin: 20px;
            justify-content: center;
            /* Center these! */
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 50px;
        }

        .color-dot {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            cursor: pointer;
            border: 4px solid rgba(255, 255, 255, 0.3);
            transition: all 0.25s ease;
            box-shadow: inset 0 -8px 15px rgba(0, 0, 0, 0.3),
                inset 0 8px 15px rgba(255, 255, 255, 0.3);
        }

        .color-dot:hover:not(.disabled) {
            transform: scale(1.15);
            box-shadow: 0 0 20px currentColor,
                inset 0 -8px 15px rgba(0, 0, 0, 0.3),
                inset 0 8px 15px rgba(255, 255, 255, 0.3);
        }

        .color-dot.selected {
            border-color: white;
            box-shadow: 0 0 25px currentColor, 0 0 40px currentColor,
                inset 0 -8px 15px rgba(0, 0, 0, 0.3),
                inset 0 8px 15px rgba(255, 255, 255, 0.3);
            transform: scale(1.2);
        }

        .color-dot.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: scale(0.85);
            filter: grayscale(50%);
        }

        .color-dot.disabled::after {
            content: '‚úï';
            position: absolute;
            color: rgba(255, 255, 255, 0.6);
            font-size: 1.5rem;
        }

        .color-options {
            display: flex;
            gap: 15px;
            margin: 15px;
            justify-content: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 18px 25px;
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Victory Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            color: white;
        }

        th,
        td {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            text-align: left;
        }

        th {
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--primary-color);
        }

        /* Connectors SVG */
        #board-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            /* Lower than player */
            filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
        }
    </style>
</head>

<body>

    <!-- Setup Screen -->
    <div id="setup-screen">
        <div class="setup-card">
            <h1>Snakes & Ladders: Grammar Edition</h1>

            <div id="difficulty-selector" style="margin: 20px 0; padding: 15px;">
                <h3 style="margin-top:0; color: #fff;">Select Difficulty</h3>
                <div id="difficulty-options"
                    style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px;">
                    <!-- Populated by JS -->
                </div>
                <div id="diff-error" style="color:#e74c3c; display:none; margin-top:5px;">Select at least one!</div>
            </div>

            <h2>Select Player Colors</h2>

            <h3>Player 1</h3>
            <div class="color-options" id="p1-colors" style="margin: 10px auto; background: transparent;">
                <!-- JS will populate -->
            </div>

            <h3>Player 2</h3>
            <div class="color-options" id="p2-colors" style="margin: 10px auto; background: transparent;">
                <!-- JS will populate -->
            </div>

            <button id="start-btn" class="dice-btn"
                style="margin-top: 30px; font-size: 1.5rem; padding: 15px 40px; background: #2ecc71; color: white; border: none; border-radius: 50px; cursor: pointer;">Start
                Game</button>
        </div>
    </div>

    <!-- UI -->
    <div id="game-container" class="hidden">
        <div id="board-container">
            <svg id="board-overlay"></svg>
            <div id="board">
                <!-- Grid generated by JS -->
            </div>
        </div>

        <div id="ui-panel">
            <div class="card">
                <h2>Current Turn</h2>
                <div id="turn-indicator" style="font-size: 1.5rem; font-weight: bold;">Player 1</div>
            </div>

            <div class="card" id="dice-container">
                <h2>Roll Dice</h2>
                <div id="dice-result">üé≤</div>
                <button id="dice-btn">ROLL</button>
            </div>

            <div class="card">
                <h2>Log</h2>
                <div id="game-log" style="max-height: 200px; overflow-y: auto; font-size: 0.9rem; color: #666;">
                    Game started!
                </div>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="quest-modal-overlay">
        <div class="modal">
            <div class="tag"
                style="background: #eee; padding: 5px 10px; border-radius: 5px; display: inline-block; margin-bottom: 15px; font-weight: bold; color: #666;">
                GRAMMAR GATE</div>
            <div id="quest-content">
                <!-- Injected Question -->
            </div>

            <div id="quest-feedback" class="feedback"></div>

            <button id="continue-btn" class="hidden"
                style="margin-top: 20px; width: 100%; padding: 15px; background: #2c3e50; color: white; border: none; border-radius: 10px; font-size: 1.2rem; cursor: pointer;">Continue</button>
        </div>
    </div>

    <!-- Victory Screen -->
    <div id="victory-screen" class="hidden">
        <div class="modal">
            <h1>üèÜ VICTORY! üèÜ</h1>
            <h2 id="winner-name">Player X Wins!</h2>

            <h3>Game Stats</h3>
            <table id="stats-table">
                <thead>
                    <tr>
                        <th>Player</th>
                        <th>Correct</th>
                        <th>Incorrect</th>
                        <th>Accuracy</th>
                    </tr>
                </thead>
                <tbody id="stats-body"></tbody>
            </table>

            <h3>Recommended Revision</h3>
            <p id="revision-text"></p>

            <button onclick="location.reload()"
                style="background: #2ecc71; color: white; padding: 15px 30px; border: none; border-radius: 10px; font-size: 1.2rem; cursor: pointer; margin-top: 20px;">Play
                Again</button>
        </div>
    </div>

    <script>
        // --- DATA INJECTION ---
        const grammarQuestions = /* GRAMMAR_QUESTIONS_PLACEHOLDER */;

        // --- GAME CONFIG ---
        const BOARD_SIZE = 100;
        const SNAKES_LADDERS = {
            // Ladders (Start < End)
            2: 38, 7: 14, 10: 31, 28: 84, 37: 44, 52: 67, 71: 91, 81: 100,
            // Snakes (Start > End)
            17: 6, 48: 26, 49: 11, 62: 2, 64: 24, 87: 66, 93: 73, 95: 75, 99: 80
        };

        // --- STATE ---
        let players = [
            { id: 0, name: "Player 1", color: "white", pos: 1, stats: { correct: 0, wrong: 0, wrongUnits: {} }, score: 0 },
            { id: 1, name: "Player 2", color: "white", pos: 1, stats: { correct: 0, wrong: 0, wrongUnits: {} }, score: 0 }
        ];
        let currentPlayerIdx = 0;
        let turnState = 'ROLL'; // ROLL, ANSWER, MOVE, EXTRA_TURN
        let pendingDiceRoll = 0;
        let currentQuestion = null;
        let selectedDifficulties = new Set(); // Stores enabled difficulties

        // --- SETUP ---
        const COLORS = ['#ecf0f1', '#e91e63', '#3498db', '#2ecc71', '#f1c40f', '#e74c3c']; // White, Pink, Blue, Green, Yellow, Red
        const COLOR_NAMES = ['White', 'Pink', 'Blue', 'Green', 'Yellow', 'Red'];

        function initSetup() {
            // Track color selections for mutual exclusion
            let p1SelectedIdx = 0; // Default Player 1 to White (index 0)
            let p2SelectedIdx = 2; // Default Player 2 to Blue (index 2)

            const updateDisabledStates = () => {
                // Update P1 colors - disable P2's selection
                document.querySelectorAll('#p1-colors .color-dot').forEach((dot, idx) => {
                    if (idx === p2SelectedIdx) {
                        dot.classList.add('disabled');
                    } else {
                        dot.classList.remove('disabled');
                    }
                    if (idx === p1SelectedIdx) dot.classList.add('selected');
                    else dot.classList.remove('selected');
                });
                // Update P2 colors - disable P1's selection
                document.querySelectorAll('#p2-colors .color-dot').forEach((dot, idx) => {
                    if (idx === p1SelectedIdx) {
                        dot.classList.add('disabled');
                    } else {
                        dot.classList.remove('disabled');
                    }
                    if (idx === p2SelectedIdx) dot.classList.add('selected');
                    else dot.classList.remove('selected');
                });
            };

            const createColorOpts = (pid, containerId) => {
                const container = document.getElementById(containerId);
                COLORS.forEach((c, idx) => {
                    const dot = document.createElement('div');
                    dot.className = 'color-dot';
                    dot.style.backgroundColor = c;
                    dot.style.position = 'relative';
                    dot.style.display = 'flex';
                    dot.style.alignItems = 'center';
                    dot.style.justifyContent = 'center';
                    dot.dataset.colorIndex = idx;

                    dot.onclick = () => {
                        // Check if disabled
                        if (dot.classList.contains('disabled')) return;

                        // Update tracked selection
                        if (pid === 0) p1SelectedIdx = idx;
                        else p2SelectedIdx = idx;

                        players[pid].color = c;
                        players[pid].colorName = COLOR_NAMES[idx];

                        // Update disabled states for both players
                        updateDisabledStates();
                    };

                    container.appendChild(dot);
                });
            };

            createColorOpts(0, 'p1-colors');
            createColorOpts(1, 'p2-colors');

            // Initial selection synchronization
            players[0].color = COLORS[p1SelectedIdx];
            players[0].colorName = COLOR_NAMES[p1SelectedIdx];
            players[1].color = COLORS[p2SelectedIdx];
            players[1].colorName = COLOR_NAMES[p2SelectedIdx];

            // Initial update of disabled and selected states
            updateDisabledStates();

            // Difficulty Setup
            const diffs = [...new Set(grammarQuestions.map(q => q.difficulty).filter(Boolean))].sort();
            // No default selection - user must explicitly choose difficulties

            const diffContainer = document.getElementById('difficulty-options');
            diffs.forEach(d => {
                const btn = document.createElement('div');
                btn.className = 'diff-btn selected';
                btn.textContent = d;
                btn.style.cssText = `
                    padding: 12px 24px; 
                    background: #2d3436; 
                    border: 2px solid var(--primary-color); 
                    border-radius: 20px; 
                    cursor: pointer; 
                    user-select: none;
                    transition: all 0.2s;
                    color: white;
                    font-size: 1.1rem;
                    font-weight: bold;
                    margin: 5px;
                `;

                // Active style helper
                const updateStyle = (active) => {
                    if (active) {
                        btn.style.background = 'var(--primary-color)';
                        btn.style.color = '#2d3436';
                        btn.style.boxShadow = '0 0 10px var(--primary-color)';
                    } else {
                        btn.style.background = 'rgba(0, 0, 0, 0.5)';
                        btn.style.color = '#ccc';
                        btn.style.boxShadow = 'none';
                    }
                };
                updateStyle(false); // Start unselected

                btn.onclick = () => {
                    if (selectedDifficulties.has(d)) {
                        selectedDifficulties.delete(d);
                        updateStyle(false);
                    } else {
                        selectedDifficulties.add(d);
                        updateStyle(true);
                    }
                };
                diffContainer.appendChild(btn);
            });

            document.getElementById('start-btn').onclick = () => {
                if (selectedDifficulties.size === 0) {
                    const err = document.getElementById('diff-error');
                    err.style.display = 'block';
                    // Shake effect
                    err.style.transform = 'translateX(5px)';
                    setTimeout(() => err.style.transform = 'translateX(0)', 100);
                    setTimeout(() => err.style.transform = 'translateX(-5px)', 200);
                    setTimeout(() => err.style.transform = 'translateX(0)', 300);
                    return;
                }

                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                renderBoard();
                updatePlayerRender();
                updateUI();
            };
        }

        // --- BOARD RENDER ---
        function renderBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';

            // Generate cells 100 down to 1
            // Boustrophedon layout logic:
            // Row 10 (top): 100 99 ... 91
            // Row 9: 81 82 ... 90
            // etc.

            for (let row = 9; row >= 0; row--) {
                const isLeftToRight = (row % 2 === 0);
                const rowStart = row * 10 + 1;
                const rowCells = [];

                for (let i = 0; i < 10; i++) {
                    rowCells.push(rowStart + i);
                }

                if (!isLeftToRight) rowCells.reverse(); // Right to Left

                rowCells.forEach(num => {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${num}`;

                    // Add number
                    cell.innerHTML = `<span class="marker">${num}</span>`;

                    // Add special markers
                    if (SNAKES_LADDERS[num]) {
                        if (SNAKES_LADDERS[num] > num) {
                            cell.classList.add('ladder-start');
                            cell.title = `Ladder to ${SNAKES_LADDERS[num]}`;
                        } else {
                            cell.classList.add('snake-start');
                            cell.title = `Snake to ${SNAKES_LADDERS[num]}`;
                        }
                    }
                    if (num === 26) cell.classList.add('golden'); // Golden square

                    board.appendChild(cell);
                });
            }

            drawConnectors();
        }

        function drawConnectors() {
            const svg = document.getElementById('board-overlay');
            svg.innerHTML = '';

            // Define gradients/defs
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            defs.innerHTML = `
                <linearGradient id="ladderGrad" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#d4a373;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#e6b88a;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#d4a373;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="snakeBody" x1="0%" y1="0%" x2="100%" y2="100%">
                     <stop offset="0%" style="stop-color:#2ecc71;stop-opacity:1" />
                     <stop offset="100%" style="stop-color:#27ae60;stop-opacity:1" />
                </linearGradient>
                <filter id="shadow">
                    <feDropShadow dx="2" dy="2" stdDeviation="2" flood-color="rgba(0,0,0,0.5)"/>
                </filter>
            `;
            svg.appendChild(defs);

            for (const [start, end] of Object.entries(SNAKES_LADDERS)) {
                const startCell = document.getElementById(`cell-${start}`);
                const endCell = document.getElementById(`cell-${end}`);
                if (!startCell || !endCell) continue;

                // Helper to get coordinates relative to board container
                const getCenter = (el) => {
                    const rect = el.getBoundingClientRect();
                    const containerRect = document.getElementById('board').getBoundingClientRect();
                    return {
                        x: rect.left + rect.width / 2 - containerRect.left,
                        y: rect.top + rect.height / 2 - containerRect.top
                    };
                }

                const p1 = getCenter(startCell);
                const p2 = getCenter(endCell);

                if (parseInt(start) > end) {
                    // Snake
                    svg.appendChild(generateSnakeSVG(p1, p2));
                } else {
                    // Ladder
                    svg.appendChild(generateLadderSVG(p1, p2));
                }
            }
        }

        function generateLadderSVG(p1, p2) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("filter", "url(#shadow)");

            // Vector Math for foolproof perpendiculars
            const vx = p2.x - p1.x;
            const vy = p2.y - p1.y;
            const len = Math.sqrt(vx * vx + vy * vy);
            const nx = -vy / len; // Normal X
            const ny = vx / len;  // Normal Y

            const width = 25; // Ladder width
            const railWidth = 6;

            // Rail Offsets
            const lx = p1.x + nx * (width / 2);
            const ly = p1.y + ny * (width / 2);
            const rx = p1.x - nx * (width / 2);
            const ry = p1.y - ny * (width / 2);

            const lx2 = p2.x + nx * (width / 2);
            const ly2 = p2.y + ny * (width / 2);
            const rx2 = p2.x - nx * (width / 2);
            const ry2 = p2.y - ny * (width / 2);

            // Styles
            const woodColor = "#8d6e63";
            const woodDark = "#5d4037";

            // Draw Rails (Thick Wood)
            // Using paths for slight organic wobble? Or just straight lines.
            // Straight lines are fine for bamboo.

            const createRail = (x1, y1, x2, y2) => {
                const r = document.createElementNS("http://www.w3.org/2000/svg", "line");
                r.setAttribute("x1", x1); r.setAttribute("y1", y1);
                r.setAttribute("x2", x2); r.setAttribute("y2", y2);
                r.setAttribute("stroke", woodColor);
                r.setAttribute("stroke-width", railWidth);
                r.setAttribute("stroke-linecap", "round");
                return r;
            };

            g.appendChild(createRail(lx, ly, lx2, ly2));
            g.appendChild(createRail(rx, ry, rx2, ry2));

            // Rungs roughly every 20px
            const steps = Math.floor(len / 20);
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                const runX1 = lx + (lx2 - lx) * t;
                const runY1 = ly + (ly2 - ly) * t;
                const runX2 = rx + (rx2 - rx) * t;
                const runY2 = ry + (ry2 - ry) * t;

                const rung = document.createElementNS("http://www.w3.org/2000/svg", "line");
                rung.setAttribute("x1", runX1); rung.setAttribute("y1", runY1);
                rung.setAttribute("x2", runX2); rung.setAttribute("y2", runY2);
                rung.setAttribute("stroke", woodDark);
                rung.setAttribute("stroke-width", "5");
                rung.setAttribute("stroke-linecap", "square");
                g.appendChild(rung);
            }

            // Vines wrapping around
            // Sine wave along the ladder length
            const vinePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            let d = `M ${lx} ${ly} `; // Start left rail

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                // Center line
                const cx = p1.x + vx * t;
                const cy = p1.y + vy * t;

                // Zig zag amplitude
                const side = (i % 2 === 0) ? 1 : -1;
                const ox = nx * (width / 2 + 5) * side;
                const oy = ny * (width / 2 + 5) * side;

                // Smooth curve? Lineto for jagged vine
                // Quadratic Bezier to smooth it
                // Let's just do C bezier
                if (i > 0) {
                    // Control point roughly halfway
                    // Simple approach: simple wave
                    const prevT = (i - 1) / steps;
                    const px = p1.x + vx * prevT;
                    const py = p1.y + vy * prevT;

                    // d += `L ${cx + ox} ${cy + oy} `;
                }
            }

            // Simplest vine: Sine wave path overlaid
            const vineAmp = width * 0.8;
            const freq = steps / 2;
            let vineD = `M ${p1.x} ${p1.y}`;
            for (let k = 0; k <= len; k += 5) {
                const t = k / len;
                const bx = p1.x + vx * t;
                const by = p1.y + vy * t;

                const wave = Math.sin(t * Math.PI * steps * 0.8) * (width * 0.6);
                const vpx = bx + nx * wave;
                const vpy = by + ny * wave;

                vineD += ` L ${vpx} ${vpy}`;
            }

            vinePath.setAttribute("d", vineD);
            vinePath.setAttribute("stroke", "#2ecc71");
            vinePath.setAttribute("stroke-width", "3");
            vinePath.setAttribute("fill", "none");
            g.appendChild(vinePath);

            // Leaves on vine
            for (let k = 20; k < len; k += 40) {
                const t = k / len;
                const bx = p1.x + vx * t;
                const by = p1.y + vy * t;
                const wave = Math.sin(t * Math.PI * steps * 0.8) * (width * 0.6);

                const leaf = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                leaf.setAttribute("cx", bx + nx * wave);
                leaf.setAttribute("cy", by + ny * wave);
                leaf.setAttribute("r", "4");
                leaf.setAttribute("fill", "#27ae60");
                g.appendChild(leaf);
            }

            return g;
        }

        function generateSnakeSVG(p1, p2) {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute("filter", "url(#shadow)");

            const vx = p2.x - p1.x;
            const vy = p2.y - p1.y;
            const dist = Math.sqrt(vx * vx + vy * vy);
            const angle = Math.atan2(vy, vx);
            const nx = -vy / dist;
            const ny = vx / dist;

            // Control points amplitude (wiggle)
            const amp = 30;

            const cp1x = p1.x + vx * 0.33 + nx * amp;
            const cp1y = p1.y + vy * 0.33 + ny * amp;

            const cp2x = p1.x + vx * 0.66 - nx * amp;
            const cp2y = p1.y + vy * 0.66 - ny * amp;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            const d = `M ${p1.x} ${p1.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${p2.x} ${p2.y}`;

            path.setAttribute("d", d);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", "url(#snakeBody)");
            path.setAttribute("stroke-width", "20"); // Thicker
            path.setAttribute("stroke-linecap", "round");
            g.appendChild(path);

            // Belly scales (dashed line on top)
            const belly = document.createElementNS("http://www.w3.org/2000/svg", "path");
            belly.setAttribute("d", d);
            belly.setAttribute("fill", "none");
            belly.setAttribute("stroke", "rgba(255,255,255,0.2)");
            belly.setAttribute("stroke-width", "12");
            belly.setAttribute("stroke-dasharray", "4, 8");
            g.appendChild(belly);

            // Head (Group to rotate)
            const headG = document.createElementNS("http://www.w3.org/2000/svg", "g");
            // Angle at start is roughly direction to CP1
            // Vector P1 -> CP1
            const hdx = cp1x - p1.x;
            const hdy = cp1y - p1.y;
            const hAngle = Math.atan2(hdy, hdx) * 180 / Math.PI;

            headG.setAttribute("transform", `translate(${p1.x}, ${p1.y}) rotate(${hAngle})`);

            // Head shape
            const head = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
            head.setAttribute("cx", "0"); head.setAttribute("cy", "0");
            head.setAttribute("rx", "16"); head.setAttribute("ry", "12");
            head.setAttribute("fill", "#2ecc71");
            headG.appendChild(head);

            // Eyes
            const eyeL = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            eyeL.setAttribute("cx", "5"); eyeL.setAttribute("cy", "-5");
            eyeL.setAttribute("r", "4"); eyeL.setAttribute("fill", "white");
            headG.appendChild(eyeL);
            const pupL = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            pupL.setAttribute("cx", "6"); pupL.setAttribute("cy", "-5");
            pupL.setAttribute("r", "1.5"); pupL.setAttribute("fill", "black");
            headG.appendChild(pupL);

            const eyeR = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            eyeR.setAttribute("cx", "5"); eyeR.setAttribute("cy", "5");
            eyeR.setAttribute("r", "4"); eyeR.setAttribute("fill", "white");
            headG.appendChild(eyeR);
            const pupR = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            pupR.setAttribute("cx", "6"); pupR.setAttribute("cy", "5");
            pupR.setAttribute("r", "1.5"); pupR.setAttribute("fill", "black");
            headG.appendChild(pupR);

            // Tongue
            const tongue = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tongue.setAttribute("d", "M -10 0 L -25 -5 M -25 -5 L -25 5"); // Simple fork attempt, inaccurate rotation
            // Better tongue: stick out front? 
            // If angle 0 is towards right (positive X), head is facing right.
            // Actually, Bezier start tangent is forward.
            // So we want tongue at -rx (back?) No, depends on P1 being Tail or Head.
            // Code assumes P1 is start. Snake logic: Head is at Start (Higher Number). Tail at End (Lower Number).
            // Visuals: Start P1 -> End P2. 
            // S & L Logic: Snakes go DOWN (Start > End). 
            // Render loop: `if (parseInt(start) > end) { // Snake }`
            // So P1 is the Head.
            // We want face at 0.
            // Tongue sticking out.

            const tongue2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tongue2.setAttribute("d", "M -16 0 L -24 0 L -28 -3 M -24 0 L -28 3");
            tongue2.setAttribute("stroke", "#e74c3c");
            tongue2.setAttribute("stroke-width", "2");
            tongue2.setAttribute("fill", "none");
            headG.appendChild(tongue2);

            g.appendChild(headG);

            return g;
        }

        function updatePlayerRender() {
            // Remove existing
            document.querySelectorAll('.player').forEach(e => e.remove());

            players.forEach(p => {
                const cell = document.getElementById(`cell-${p.pos}`);
                if (cell) {
                    const piece = document.createElement('div');
                    piece.className = 'player pop-in';
                    piece.style.setProperty('--player-color', p.color);

                    // Refined SVG Blob Character
                    piece.innerHTML = `
                        <svg class="blob-svg" viewBox="0 0 100 100">
                            <!-- Body with soft shadow -->
                            <path class="blob-body" d="M15,85 Q15,15 50,15 Q85,15 85,85 Z" />
                            
                            <!-- Blush -->
                            <ellipse cx="30" cy="55" rx="8" ry="4" fill="#ff80ab" opacity="0.5" />
                            <ellipse cx="70" cy="55" rx="8" ry="4" fill="#ff80ab" opacity="0.5" />
                            
                            <!-- Eyes with shine -->
                            <g class="blob-eyes">
                                <circle cx="38" cy="45" r="5" fill="#2d3436" />
                                <circle cx="40" cy="43" r="1.5" fill="white" />
                                <circle cx="62" cy="45" r="5" fill="#2d3436" />
                                <circle cx="64" cy="43" r="1.5" fill="white" />
                            </g>
                            
                            <!-- Expression (Happy Smile) -->
                            <path d="M42,65 Q50,72 58,65" stroke="#2d3436" stroke-width="2.5" fill="none" stroke-linecap="round" />
                            
                            <!-- Body Reflection/Highlight -->
                            <path d="M30,30 Q50,25 70,30" stroke="white" stroke-width="3" fill="none" opacity="0.3" stroke-linecap="round" />
                        </svg>
                    `;

                    // Little offset if sharing cell
                    const playersInCell = players.filter(pl => pl.pos === p.pos);
                    const idx = playersInCell.indexOf(p);
                    const offset = idx * 8;
                    piece.style.transform = `translate(${offset}px, ${offset}px)`;

                    cell.appendChild(piece);
                }
            });
        }

        function updateUI() {
            const p = players[currentPlayerIdx];
            document.getElementById('turn-indicator').textContent = `${p.name} (${p.colorName})`;
            document.getElementById('turn-indicator').style.color = p.color === '#ecf0f1' ? '#000' : p.color;
        }

        function log(msg) {
            const log = document.getElementById('game-log');
            const entry = document.createElement('div');
            entry.textContent = msg;
            log.prepend(entry);
        }

        // --- GAME LOGIC ---

        document.getElementById('dice-btn').onclick = handleDiceClick;

        function handleDiceClick() {
            if (turnState !== 'ROLL') return;

            // NEW LOGIC: Show Question FIRST. No roll yet.
            log(`${players[currentPlayerIdx].name} begins turn...`);

            // Present Grammar Gate Question
            showGrammarGate(players[currentPlayerIdx]);
        }

        function showGrammarGate(player) {
            const overlay = document.getElementById('quest-modal-overlay');
            overlay.style.display = 'flex';

            // Pick random question from SELECTED difficulties
            const availableQs = grammarQuestions.filter(q =>
                selectedDifficulties.has(q.difficulty)
            );

            // Fallback if empty (shouldn't happen due to check at start)
            const pool = availableQs.length > 0 ? availableQs : grammarQuestions;

            // If player has lots of wrong answers in a unit, prioritise that unit logic could go here
            // For now, random
            const q = pool[Math.floor(Math.random() * pool.length)];
            currentQuestion = q;

            const content = document.getElementById('quest-content');
            content.innerHTML = `
            <h3 class="question-text">${q.question || "Fill in the blank:"}</h3>
            <div class="options-grid">
                ${q.options.map((opt, i) => `
                    <button class="option-btn" onclick="handleAnswer(${i})">${opt}</button>
                `).join('')}
            </div>
            <p style="margin-top:20px; color:#999; font-size: 0.8rem;">Unit ${q.units} ‚Ä¢ ${q.topic} ‚Ä¢ ${q.difficulty}</p>
        `;

            // Hide feedback
            document.getElementById('quest-feedback').style.display = 'none';
            document.getElementById('continue-btn').classList.add('hidden');
        }

        // --- MOVEMENT ANIMATION ---
        async function movePlayerStepByStep(player, steps) {
            const startPos = player.pos;
            const targetPos = Math.min(player.pos + steps, 100);

            // Step-by-step movement
            for (let i = startPos + 1; i <= targetPos; i++) {
                player.pos = i;
                updatePlayerRender();

                // Add jump/squash effect
                const pEl = document.querySelector(`.player[style*="--player-color: ${player.color}"]`);
                if (pEl) {
                    pEl.classList.add('moving');
                    setTimeout(() => pEl.classList.remove('moving'), 300);
                }

                await new Promise(r => setTimeout(r, 400)); // Hop delay
            }

            // Check for Snakes/Ladders AFTER landing
            if (SNAKES_LADDERS[player.pos]) {
                await new Promise(r => setTimeout(r, 500)); // Pause before slide
                const endPos = SNAKES_LADDERS[player.pos];
                if (endPos && endPos >= 1 && endPos <= 100) {
                    player.pos = endPos;
                    updatePlayerRender();
                } else {
                    console.error("Invalid Snake/Ladder destination:", endPos);
                }
            }

            // Check Win
            if (player.pos === 100) {
                handleWin(player);
                return true;
            }
            return false;
        }

        async function animateDiceRoll() {
            const resultEl = document.getElementById('dice-result');
            const faces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

            // Shake animation
            for (let i = 0; i < 10; i++) {
                resultEl.textContent = faces[Math.floor(Math.random() * 6)];
                resultEl.style.transform = `rotate(${Math.random() * 20 - 10}deg) scale(1.2)`;
                await new Promise(r => setTimeout(r, 80));
            }
            resultEl.style.transform = 'none';

            const roll = Math.floor(Math.random() * 6) + 1;
            pendingDiceRoll = roll;
            // keeping number for clarity as per previous design
            document.getElementById('dice-result').textContent = roll;

            log(`${players[currentPlayerIdx].name} rolled a ${roll}!`);
            return roll;
        }

        window.handleAnswer = async (idx) => { // Async for animation
            const p = players[currentPlayerIdx];
            const isCorrect = currentQuestion.correctIndices.includes(idx);

            const feedback = document.getElementById('quest-feedback');
            feedback.style.display = 'block';
            feedback.className = isCorrect ? 'feedback correct' : 'feedback wrong';

            if (isCorrect) {
                feedback.innerHTML = `
                    <span class="feedback-title">Correct!</span>
                    <div class="rule-box">
                        Rolling Dice to move...
                    </div>
                `;
                p.stats.correct++;

                // Wait for player to see "Correct"
                await new Promise(r => setTimeout(r, 1000));
                document.getElementById('quest-modal-overlay').style.display = 'none';

                // NEW SEQUENCE: ROLL DICE NOW
                await animateDiceRoll();

                // Wait a beat to see result
                await new Promise(r => setTimeout(r, 500));

                // ANIMATE MOVEMENT NOW
                const won = await movePlayerStepByStep(p, pendingDiceRoll);
                if (won) return;

                if (pendingDiceRoll === 6) {
                    document.getElementById('turn-indicator').innerText = `${p.name} rolled a 6! Extra Turn!`;
                    turnState = 'ROLL';
                } else {
                    endTurn();
                }

            } else {
                feedback.innerHTML = `
                    <span class="feedback-title">Incorrect.</span>
                    <div class="rule-box">
                        <em>${currentQuestion.rule}</em>
                        <strong>Example:</strong> ${currentQuestion.example}
                    </div>
                    <span>You must answer another question to move!</span>
                `;
                p.stats.wrong++;
                // track unit
                const units = currentQuestion.units.split(',').map(u => u.trim());
                units.forEach(u => {
                    p.stats.wrongUnits[u] = (p.stats.wrongUnits[u] || 0) + 1;
                });

                // Set continue action -> New Question (Loop)
                const contBtn = document.getElementById('continue-btn');
                contBtn.classList.remove('hidden');
                contBtn.onclick = () => {
                    // Logic to find new question from same unit
                    const sameUnitQs = grammarQuestions.filter(q => q.units === currentQuestion.units && q !== currentQuestion);
                    const nextQ = sameUnitQs.length > 0 ? sameUnitQs[Math.floor(Math.random() * sameUnitQs.length)] : currentQuestion;
                    renderQuestionContent(nextQ);
                };
            }
        };

        function renderQuestionContent(q) {
            currentQuestion = q;
            const content = document.getElementById('quest-content');
            content.innerHTML = `
            <h3 class="question-text">${q.question || "Fill in the blank:"}</h3>
            <div class="options-grid">
                ${q.options.map((opt, i) => `
                    <button class="option-btn" onclick="handleAnswer(${i})">${opt}</button>
                `).join('')}
            </div>
            <p style="margin-top:20px; color:#999; font-size: 0.8rem;">Unit ${q.units} ‚Ä¢ ${q.topic} ‚Ä¢ ${q.difficulty}</p>
        `;
            document.getElementById('quest-feedback').style.display = 'none';
            document.getElementById('continue-btn').classList.add('hidden');
        }

        function movePlayer(player, steps) {
            const startPos = player.pos;
            let newPos = startPos + steps;

            if (newPos > 100) {
                // Bounce or Stay? Standard rule is usually bounce or exact roll. Let's say exact roll needed? 
                // Or just cap at 100. Prompt implies "Upon reaching square 100".
                // Let's just clamp to 100 for simplicity and kid-friendliness
                newPos = 100;
            }

            player.pos = newPos;
            updatePlayerRender();
            log(`${player.name} moved to ${player.pos}`);

            // Check Win
            if (newPos === 100) {
                handleWin(player);
                return;
            }

            // Check Snake/Ladder
            // Animate delay
            setTimeout(() => {
                if (SNAKES_LADDERS[newPos]) {
                    const dest = SNAKES_LADDERS[newPos];
                    const isLadder = dest > newPos;
                    log(`${player.name} hit a ${isLadder ? 'Ladder! ü™ú' : 'Snake! üêç'} Moving to ${dest}.`);
                    player.pos = dest;
                    updatePlayerRender();
                }

                // End Turn Logic
                endTurn();

            }, 500);
        }

        function endTurn() {
            // "6" Rule: Rolling a 6 earns an extra turn, but... must answer second question.
            // My implementation asks question BEFORE move. So if they rolled 6 and got it right, they moved.
            // Now if pendingDiceRoll was 6, they get another turn.
            if (pendingDiceRoll === 6) {
                log("Rolled a 6! Extra Turn!");
                // Stay on current player
                turnState = 'ROLL';
            } else {
                // Next player
                currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
                turnState = 'ROLL';
                updateUI();
            }
        }

        function handleWin(player) {
            document.getElementById('victory-screen').classList.remove('hidden');
            document.getElementById('winner-name').textContent = `${player.name} Wins!`;

            const tbody = document.getElementById('stats-body');
            tbody.innerHTML = '';

            players.forEach(p => {
                const tr = document.createElement('tr');
                const total = p.stats.correct + p.stats.wrong;
                const acc = total === 0 ? 0 : Math.round((p.stats.correct / total) * 100);
                tr.innerHTML = `
                <td>${p.name}</td>
                <td>${p.stats.correct}</td>
                <td>${p.stats.wrong}</td>
                <td>${acc}%</td>
            `;
                tbody.appendChild(tr);
            });

            // Revision Plan
            // Sort wrongUnits by count
            const revision = Object.entries(player.stats.wrongUnits)
                .sort((a, b) => b[1] - a[1]) // desc
                .slice(0, 3) // top 3
                .map(([unit, count]) => `Unit ${unit} (${count} errors)`);

            if (revision.length > 0) {
                document.getElementById('revision-text').textContent = "Focus revision on: " + revision.join(', ');
            } else {
                document.getElementById('revision-text').textContent = "Great job! No specific revision needed.";
            }
        }

        // Start
        initSetup();

    </script>
</body>

</html>